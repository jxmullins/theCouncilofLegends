**On scope** – Partition by constraints, not line-count. “Systems” where Rust is decisively superior share traits: (1) hard/soft real-time or tight tail SLOs (<1–2 ms p99), (2) memory/layout control (allocators, pinning, cache shape), (3) foreign-ABI friendliness, (4) runtimes you must avoid (no GC, no moving objects). This covers kernels, drivers, embedded, DB/storage engines, proxies/data-plane services, crypto, stream processors, game/netcode. Go excels in control planes and fleet/distributed orchestration where GC and scheduler variability are acceptable and developer throughput dominates. Even if cloud control-plane code volume is larger, the operational risk and cost density live in the data plane—where Rust’s guarantees matter most.

**API gateway at 100K req/s (concrete risks)**  
- Go: GC removes use-after-free, but you’re exposed to tail spikes under alloc churn or large heaps (even 5–15 ms pauses dent p99.9). Goroutine leaks under backpressure, forgotten `cancel()` on contexts, channel misuse (double close, send on closed) manifest in production. Data races slip past code review unless the race detector runs; tight budgets discourage its use in perf environments. Escape analysis surprises can heap-allocate hot structs. Operationally, you may spend weeks tuning GOGC, pacing, and pool/buffer reuse to stabilize tails.  
- Rust: No GC, so you avoid pause-induced tail jitter; ownership forbids use-after-free and prevents races unless you opt into `unsafe` or share via sync types. Common failures are borrow-checker friction up front and occasional async executor surprises (unbounded tasks) but these surface at compile/test time. Development time is slower early (wrangling lifetimes), but operational time is saved by not firefighting GC pauses or latent races. For a gateway, predictable tails usually trump a faster initial sprint.

**Goroutines vs ownership in a coordinator**  
- Go strengths: spawning work with `go fn()` and channel fan-in is quick to write. Weaknesses: easy to leak goroutines when a parent cancels; channel closure order bugs; shared `map` without locks/races unless guarded; slice aliasing leads to accidental shared mutation; reasoning about ownership across layers relies on discipline, tests, and the race detector.  
- Rust strengths: ownership forces explicit sharing (`Arc<Mutex<T>>`, `RwLock`, `Atomic*`), so unsynchronized shared mutation won’t compile. RAII ensures locks and resources release even on early returns. With `tokio::select!`/`JoinSet` you get structured concurrency and cancellation that is enforced by lifetimes rather than convention. Downside: designing APIs that satisfy the borrow checker takes more up-front thought, and beginners fight it—yet that work encodes invariants the compiler maintains.

**Rebuttal to Claude**  
Go’s velocity is real for control planes; I concede it wins there. But superiority in systems hinges on predictability under load and memory safety without a runtime tax. The domains where failure is most expensive align with Rust’s guarantees. Even in “cloud-native,” the hot path (proxies, sidecars, service meshes) increasingly moves from Go to Rust for tail latency and safety (e.g., Linkerd data plane rewrite).

**Bottom line** – If the system’s success depends on tight latency, memory/layout control, and FFI boundaries, Rust is the superior choice. Go remains excellent for fast-moving control planes, but that doesn’t overturn the resolution for systems programming’s most risk-sensitive tiers.
